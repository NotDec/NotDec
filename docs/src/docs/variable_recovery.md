# 变量恢复

在使用高层语言的时候，编译器会潜在地帮我们做一些事情。比如访问结构体成员，访问数组下标，对应的底层代码会执行对应的指针运算。

编译到底层二进制代码的过程中会丢失很多信息，比如加法和指针运算的混淆。整数类型和指针类型的混淆。

因此面对底层二进制类型的时候，同时要考虑可能存在的高层类型映射。对于加法运算，同时产生三种约束，包括指针。基于汇编代码的使用，可以部分推测出代码中原始的信息。

- [CMU Lecture Notes on Decompilation (15411: Compiler Design)](https://www.cs.cmu.edu/~fp/courses/15411-f13/lectures/20-decompilation.pdf) 

**基于约束求解的方法** 考虑到可能存在的约束，我们需要重新对这些分析执行约束求解。

**基于格和数据流分析**

### 寻找栈指针

栈指针访问的识别：在第一个基本块，在任何内存访问之前，是否对全局变量进行了一读一写的修改，且写的是读出的值加一个常量。是的话就认为是栈指针。

```llvm
%0 = load i32, i32* @"$__stack_pointer", align 4
%1 = sub i32 %0, 32
store i32 %1, i32* @"$__stack_pointer", align 4
```

**Pattern Matching and Canonical Form**
一个明显的问题：我们模式匹配的时候，需要考虑
- 栈的增长方向，决定了指令可能是add还是sub
- 加法指令的分配律问题：需要考虑load的结果在add的左边还是右边，但是规则匹配不支持这种分配律的情况

然而：
- 这些问题，显然，在编译器的窥孔优化等问题中也存在
- 可以观察到，在增加了优化相关的Pass之后，sub指令甚至变成了`add xxx, -32`这种形式。

在编译优化中为了解决这个问题，往往会引入指令的canonical form，统一把这种分配律的自由问题限制一下，规定一下谁在左谁在右。比如我们这里的例子，加减常量统一使用add指令（减的话就是加一个负数），且常量在右边。[这个帖子](https://www.npopov.com/2023/04/10/LLVM-Canonicalization-and-target-independence.html) 有一些更详细的介绍。即：有了InstCombine这个Pass之后，至少对于这种常量加减的情况，我们可以放心地只匹配一部分模式了？


### 基于retypd的类型恢复

基于retypd恢复类型，我们只需要为每个函数生成约束。然后生成一个调用图。将这两个东西喂给retypd，再解析分析结果得到类型即可。

### 类型问题

例子：`_arg_0.@0+1i[0].load8 <= char`  其中`_arg_0`到底是什么类型

是完全从结构体的角度考虑的话。数组类型是不能够单独存在的。 基本上都是数组指针类型。 图的角度可以这样考虑，但是由于数组指针类型不够通用，这种类型则生成时完全被弃用。（char (*_arg_0)[0]）解析结构体成员的每个类型的时候还是需要数组类型的，方便把数组内嵌到结构体内部。 
另一种方式是把数组类型看作是指针类型。同时暗示了这个指针可能会越界读相同类型的东西。 这种方式本质上还是使用的是数组的第一个成员的指针类型。 如果基于这样的思想去生成类型，则反过来，不要从结构体的角度考虑。 
有一个矛盾的想法。就是基于第一点，类型应该是char (*_arg_0)[0]，然后基于 数组类型是指针类型 得到 类型等价于 char ** 这种想法是大错特错的。
关键在于不能让数组指针类型在等式的左侧。即变成左值。 只要这个类型有被用于左值的风险。 就需要去退化。 在程序中，往往是通过。 数组变量无法被赋值实现的。 即（对char a[2] 不能有 a = xxx;）

总结，完全按照结构体的角度考虑，但是如果一个值有可能是左值，则它的类型里必须把所有的数组类型给去掉（退化操作）。
