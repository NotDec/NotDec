<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>NotDec: Decompiler From Scratch</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="llvm.html"><strong aria-hidden="true">1.</strong> LLVM Basics</a></li><li class="chapter-item expanded "><a href="docs/index.html"><strong aria-hidden="true">2.</strong> NotDec Development Document</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="docs/wasm-frontend.html"><strong aria-hidden="true">2.1.</strong> WebAssembly Frontend</a></li><li class="chapter-item expanded "><a href="docs/optimizers.html"><strong aria-hidden="true">2.2.</strong> Decompiler Middle End</a></li></ol></li><li class="chapter-item expanded "><a href="ghidra.html"><strong aria-hidden="true">3.</strong> Ghidra</a></li><li class="chapter-item expanded "><a href="retdec.html"><strong aria-hidden="true">4.</strong> RetDec</a></li><li class="chapter-item expanded "><a href="retypd.html"><strong aria-hidden="true">5.</strong> Retypd</a></li><li class="chapter-item expanded "><a href="papers.html"><strong aria-hidden="true">6.</strong> Papers</a></li><li class="chapter-item expanded "><a href="basics/index.html"><strong aria-hidden="true">7.</strong> Other Notes</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basics/C++.html"><strong aria-hidden="true">7.1.</strong> C++</a></li><li class="chapter-item expanded "><a href="basics/cmake.html"><strong aria-hidden="true">7.2.</strong> CMake</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">NotDec: Decompiler From Scratch</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="notdec-a-webassembly-decompiler-for-static-analysis"><a class="header" href="#notdec-a-webassembly-decompiler-for-static-analysis">NotDec: A WebAssembly Decompiler for Static Analysis</a></h1>
<p><a href="index.html#%E4%B8%AD%E6%96%87">中文</a></p>
<p>NotDec is</p>
<ol>
<li>A project that aims to demystify the internal of decompiler.</li>
<li>A webassembly to LLVM IR lifter that generates clean code, optimized for static analysis.
<ul>
<li>Binary Rewriting Framework (convert the IR back to webassembly) (TODO)</li>
</ul>
</li>
<li>A webassembly decompiler
<ul>
<li>Variable Recovery</li>
<li>Structual Analysis</li>
</ul>
</li>
</ol>
<h1 id="中文"><a class="header" href="#中文">中文</a></h1>
<h2 id="todo"><a class="header" href="#todo">TODO</a></h2>
<ol>
<li>将wasm lift到LLVM IR
<ul>
<li>支持将wasm内存直接映射到某个基地址，从而直接支持运行，以及memory grow相关指令。</li>
<li>支持DWARF调试信息，从而映射回原wat，wasm</li>
</ul>
</li>
<li>设计一个映射，将lift之后的IR反向转回wasm</li>
</ol>
<h2 id="反编译器"><a class="header" href="#反编译器">反编译器</a></h2>
<p>侧重于前中端（转IR与IR的优化。）</p>
<h3 id="从零实现反编译器"><a class="header" href="#从零实现反编译器">从“零”实现反编译器</a></h3>
<p>为什么要从零开始？为了更好地学习反编译器的原理。即使最后改为对接现有的反编译器。</p>
<p>怎么样的从零？可以使用现有的disassembler，IR，compiler等，但是不能直接去对接现有的反编译器。前期可以使用一些LLVM的Pass，后期最好都替换为自己写的Pass。</p>
<p>计划产出：</p>
<ol>
<li>反编译器自身：能够对“内存”中的变量也构建SSA进行优化。</li>
<li>最终的结果能够很好地重编译。</li>
<li>反编译器实现过程尽量记录完善的文档，未来考虑整理扩写为系列教程。</li>
</ol>
<h3 id="不知道接下来怎么办资料收集"><a class="header" href="#不知道接下来怎么办资料收集">不知道接下来怎么办？（资料收集）</a></h3>
<p>学习阶段：</p>
<ol>
<li>
<p>LLVM IR基础：只要达到能手写LLVM IR的程度就行。即主要理解各种语言特性对应的是什么样的LLVM IR代码。同时理解带alloca的半SSA形式，即alloca里的变量是非SSA，外面的是SSA。</p>
<ul>
<li>llvm-tutor </li>
<li>ollvm源码</li>
</ul>
</li>
<li>
<p>SSA与编译优化基础</p>
<ul>
<li><a href="https://book.douban.com/subject/20436488/">《Engineering a compiler》</a> 上来先看9.3章，深入研读。其他的章节没那么重要</li>
<li>再找找其他讲过SSA的中文书？</li>
</ul>
<p>下面有两个实验，动手做了印象才会深</p>
<ul>
<li><a href="https://buaa-se-compiling.github.io/miniSysY-tutorial/challenge/mem2reg/help.html">mem2reg 实验指导 · GitBook (buaa-se-compiling.github.io)</a></li>
<li><a href="https://pku-minic.github.io/online-doc/#/lv9p-reincarnation/ssa-form">Lv9+.4. SSA 形式 - 北京大学编译实践课程在线文档 | 北大编译实践在线文档 (pku-minic.github.io)</a></li>
</ul>
<p>其他不错的资料：</p>
<ul>
<li><a href="https://pfalcon.github.io/ssabook/latest/book-v1.pdf">《SSA book》</a></li>
<li><a href="https://pp.info.uni-karlsruhe.de/uploads/publikationen/braun13cc.pdf">《simple and efficient ssa construction》</a></li>
</ul>
</li>
<li>
<p>反编译</p>
</li>
</ol>
<h4 id="直接相关的资料"><a class="header" href="#直接相关的资料">直接相关的资料</a></h4>
<p>多看看现有的资料：</p>
<ol>
<li>Static Single Assignment for Decompilation vanEmmerik_ssa https://yurichev.com/mirrors/vanEmmerik_ssa.pdf</li>
<li><a href="https://github.com/avast/retdec/tree/master/publications">retdec/publications at master · avast/retdec (github.com)</a> 
<ol>
<li>综述是<a href="http://www.fit.vutbr.cz/study/DP/PD.php?id=482&amp;file=t">Retargetable Analysis of Machine Code</a> </li>
</ol>
</li>
</ol>
<p>参考现有的反编译器：</p>
<ol>
<li>Ghidra <a href="https://github.com/NationalSecurityAgency/ghidra/blob/master/Ghidra/Features/Decompiler/src/decompile/cpp/docmain.hh">ghidra/docmain.hh at master · NationalSecurityAgency/ghidra (github.com)</a> 看代码前构建doxygen看文档。</li>
<li><a href="https://github.com/avast/retdec">avast/retdec: RetDec is a retargetable machine-code decompiler based on LLVM. (github.com)</a></li>
<li><a href="https://boomerang.sourceforge.net/">Boomerang Decompiler (sourceforge.net)</a>     <a href="https://github.com/BoomerangDecompiler/boomerang">BoomerangDecompiler/boomerang: Boomerang Decompiler - Fighting the code-rot :) (github.com)</a> </li>
<li><a href="https://github.com/yegord/snowman">yegord/snowman: Snowman decompiler (github.com)</a> </li>
<li>angr好像也有了</li>
</ol>
<p>也要学习程序分析的内容。</p>
<p><a href="https://github.com/SVF-tools/SVF">SVF-tools/SVF: Static Value-Flow Analysis Framework for Source Code (github.com)</a> </p>
<p>控制流恢复算法：</p>
<ol>
<li><a href="https://www.ndss-symposium.org/ndss2015/ndss-2015-programme/no-more-gotos-decompilation-using-pattern-independent-control-flow-structuring-and-semantics/">No More Gotos: Decompilation Using Pattern-Independent Control-Flow Structuring and Semantics-Preserving Transformations – NDSS Symposium (ndss-symposium.org)</a> </li>
<li>Phoenix: [Schwartz et al._2013_Native x86 Decompilation using Semantics-Preserving Structural Analysis and Iterative Control-Flow Structuring.pdf (cmu.edu)](https://users.ece.cmu.edu/~dbrumley/pdf/Schwartz et al._2013_Native x86 Decompilation using Semantics-Preserving Structural Analysis and Iterative Control-Flow Structuring.pdf) </li>
</ol>
<h3 id="规划基于llvm-ir的反编译"><a class="header" href="#规划基于llvm-ir的反编译">规划：基于LLVM IR的反编译</a></h3>
<p>为什么要使用LLVM IR？</p>
<ol>
<li>之后可以直接对接SVF，得到较好的指针分析结果。</li>
</ol>
<p>优先实现wasm的反编译。</p>
<ol>
<li>Wasm转LLVM IR
<ol>
<li>WAVM是一个基于LLVM的wasm的JIT，有部分逻辑是WASM转 LLVM IR
<ol>
<li>生成的IR不够简洁，有很多为了编译到汇编的冗余的内容</li>
</ol>
</li>
</ol>
</li>
<li></li>
</ol>
<h3 id="规划反编译阶段"><a class="header" href="#规划反编译阶段">规划：反编译阶段</a></h3>
<p><img src="docs/imgs/decompiler-architecture.png" alt="反编译的各个阶段" /></p>
<p>图片来自<a href="https://yurichev.com/mirrors/vanEmmerik_ssa.pdf">Static Single Assignment for Decompilation</a></p>
<p>反编译中的关键算法： Type Recovery（通过指令约束推导类型） Structual Analysis(恢复控制流)</p>
<ol>
<li>前端：将字节码转为LLVM IR</li>
<li>中端：优化与分析
<ol>
<li>分析函数参数、分析callee saved register (wasm可以跳过这个阶段)</li>
<li>SSA构建：使得前端可以有些冗余的alloca，由SSA构建来将相关alloca消除。 （编译原理相关）</li>
<li>GVNGCM：Global Value Numbering and Global Code Motion 优化算法，有强大的优化能力，有助于反混淆等。（编译原理相关）</li>
<li>内存分析：将各种通过内存访问的变量显式地恢复出来。可能要用到指针分析算法，类型恢复等。关键词：Memory SSA。</li>
</ol>
</li>
<li>后端：高层控制流恢复，将字节码转为AST，打印为高级语言的形式。</li>
</ol>
<h3 id="项目架构与工具"><a class="header" href="#项目架构与工具">项目架构与工具</a></h3>
<p>Markdown编辑器（建议）使用Typora，或VSCode</p>
<p>由于基于LLVM IR，因此语言采用C++。</p>
<p>开发环境：VSCode + CMake。将Wabt，LLVM等作为CMake的外部依赖。</p>
<h4 id="开发环境搭建---devcontainer"><a class="header" href="#开发环境搭建---devcontainer">开发环境搭建 - DevContainer</a></h4>
<p>VSCode DevContainer。出于<a href="https://code.visualstudio.com/remote/advancedcontainers/improve-performance">性能考虑</a>，在clone时可以直接clone到wsl的ext4文件系统里。</p>
<ol>
<li>安装Docker Desktop on Windows： https://docs.docker.com/desktop/install/windows-install/ （无论是家庭版还是专业版均可）
<ol>
<li>其他系统直接安装docker</li>
</ol>
</li>
<li>用vscode打开代码，安装Dev Containers插件，按Ctrl-Shift-P 然后输入查找 <code>Remote-Containers: Rebuild and Reopen in container</code>.</li>
<li>等待构建，构建完成后会直接进入开发环境中。</li>
<li>安装CMake相关插件，toolkit选clang。</li>
</ol>
<p>如果出现了无法使用windows侧的ssh-agent提供的ssh key的forward功能：
https://stackoverflow.com/questions/72293035/error-communication-with-agent-failed-when-ssh-auth-sock-is-set-but-ssh-agent </p>
<h4 id="开发环境搭建---linux"><a class="header" href="#开发环境搭建---linux">开发环境搭建 - Linux</a></h4>
<p>基于Ubuntu系统。</p>
<ol>
<li>软件安装
<ul>
<li>apt安装
<pre><code>sudo apt install wabt python-is-python3 clang-14 cmake zlib1g-dev g++
</code></pre>
</li>
<li>安装wasi-sdk到/opt
<pre><code>wget https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-20/wasi-sdk-20.0-linux.tar.gz -P /tmp
sudo tar xf /tmp/wasi-sdk-20.0-linux.tar.gz -C /opt
</code></pre>
</li>
</ul>
</li>
<li>clone 本仓库</li>
<li>安装LLVM 14
<ul>
<li>方式1：下载提前构建好的LLVM，解压得到<code>llvm-14.0.6.obj</code>文件夹，放到项目根目录。</li>
<li>方式2：执行<code>scripts/build-debug-llvm.sh</code>脚本，下载并构建LLVM源码。中途可能遇到内存不足的情况，需要手动降低并行数量到1。
成功构建后可以将<code>llvm-14.0.6.obj</code>文件夹打包发送给其他人。</li>
</ul>
</li>
<li>cmake build本仓库</li>
</ol>
<h4 id="代码调试"><a class="header" href="#代码调试">代码调试</a></h4>
<p>直接使用自带的C/C++调试，不知道为什么会非常慢，gdb执行backtrace要卡3秒，各种step命令要卡5-6秒。因此安装使用CodeLLDB插件。</p>
<p>代码补全使用clangd插件。根据提示禁用Intellisense，然后确认下载一个clangd。</p>
<h3 id="提交代码前"><a class="header" href="#提交代码前">提交代码前</a></h3>
<ol>
<li>写好commit message，简要概况所有的修改。</li>
<li>检查添加的代码的注释和文档是否充足。</li>
</ol>
<h3 id="其他"><a class="header" href="#其他">其他</a></h3>
<p>各种杂七杂八的事情随意地列在这里</p>
<ol>
<li>反编译优化后重新编译，和原有代码对比测试。效果好甚至可以作为字节码的优化器。</li>
<li>未来实现得够好之后，可以重写README，该文档可以改名为<code>plan.md</code>放到docs文件夹里。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="llvm-basics"><a class="header" href="#llvm-basics">LLVM Basics</a></h1>
<h3 id="资料"><a class="header" href="#资料">资料</a></h3>
<p>书籍：
<a href="https://github.com/xiaoweiChen/Learn-LLVM-12">Learning LLVM 12（中文版）</a></p>
<p><a href="https://github.com/xiaoweiChen/LLVM-Techniques-Tips-and-Best-Practies">LLVM-Techniques-Tips-and-Best-Practies（中文版）</a></p>
<p>如何操作LLVM IR：</p>
<ol>
<li>https://mukulrathi.com/create-your-own-programming-language/llvm-ir-cpp-api-tutorial/</li>
<li>可以使用<code>llc -march=cpp</code> ： https://stackoverflow.com/questions/7787308/how-can-i-declare-a-global-variable-in-llvm </li>
<li>https://llvm.org/docs/LangRef.html 查询IR</li>
</ol>
<p>中端优化：</p>
<ul>
<li>实现自己的mem2reg(SSA construction)：https://www.zzzconsulting.se/2018/07/16/llvm-exercise.html</li>
<li>中端优化为什么这么神奇：https://blog.matthieud.me/2020/exploring-clang-llvm-optimization-on-programming-horror/</li>
</ul>
<p>YouTube的LLVM频道里有很多不错的视频。</p>
<ul>
<li>
<p>2019 LLVM Developers’ Meeting: E. Christopher &amp; J. Doerfert “Introduction to LLVM” </p>
<p>果然后端的水很深啊。</p>
</li>
<li>
<p>2019 EuroLLVM Developers’ Meeting: V. Bridgers &amp; F. Piovezan “LLVM IR Tutorial - Phis, GEPs and other things, oh my! - Vince Bridgers (Intel Corporation)”》</p>
<p>讲getelementptr指令讲得特别好，要是当时理解debug info metadata的时候看了这个就好了。</p>
</li>
<li>
<p>2019 LLVM Developers’ Meeting: J. Paquette &amp; F. Hahn “Getting Started With LLVM: Basics”</p>
<p>前半 讲了LLVM IR Pass需要考虑到的一些东西，users的概念，讲了移除基本块和指令时需要注意的。 后半部分讲Backend Pass也非常不错。</p>
</li>
<li>
<p>2019 LLVM Developers’ Meeting: S. Haastregt &amp; A. Stulova “An overview of Clang ”</p>
<p>讲了clang前端的架构。和之前想象中有些不一样。先是driver，然后是前端：词法分析语法分析，生成AST后codegen生成IR。</p>
</li>
<li>
<p>2017 LLVM Developers’ Meeting: D. Michael “XRay in LLVM: Function Call Tracing and Analysis ” </p>
<p>非常不错的Hook介入的框架</p>
</li>
<li>
<p>2018 EuroLLVM Developers’ Meeting: C. Hubain &amp; C. Tessier “Implementing an LLVM based Dynamic Binary Instrumentation framework  - Charles Hubain </p>
<p>是Quarkslab的那个QBDI，有时间真得好好学学。</p>
</li>
<li>
<p>2017 LLVM Developers’ Meeting: “Challenges when building an LLVM bitcode Obfuscator ” </p>
<p>汇编混淆确实需要考虑很多情况。。</p>
</li>
<li>
<p>2014 LLVM Developers’ Meeting: “Debug Info Tutorial ”</p>
</li>
<li>
<p>2019 LLVM Developers’ Meeting: S. Haastregt &amp; A. Stulova “An overview of Clang ”</p>
<p>讲了clang前端的架构。和之前想象中有些不一样。先是driver，然后是前端：词法分析语法分析，生成AST后codegen生成IR。</p>
</li>
<li>
<p>2017 LLVM Developers’ Meeting: D. Michael “XRay in LLVM: Function Call Tracing and Analysis</p>
<p>非常不错的Hook介入的框架</p>
</li>
<li>
<p>2018 EuroLLVM Developers’ Meeting: C. Hubain &amp; C. Tessier “Implementing an LLVM based Dynamic Binary Instrumentation framework  - Charles Hubain </p>
<p>是Quarkslab的那个QBDI，有时间真得好好学学。</p>
</li>
<li>
<p>2017 LLVM Developers’ Meeting: “Challenges when building an LLVM bitcode Obfuscator ” </p>
<p>汇编混淆确实需要考虑很多情况。</p>
</li>
</ul>
<p>其他：</p>
<ul>
<li>language server
<ul>
<li><a href="https://www.youtube.com/watch?v=5HIyAXj1YNQ">CppCon 2018: Ilya Biryukov “Clangd: architecture of a scalable C++ language server” - YouTube</a></li>
<li><a href="https://www.apress.com/br/book/9781484277911">Language Server Protocol and Implementation</a> </li>
<li><a href="https://www.oreilly.com/library/view/modern-vim/9781680506006/f_0057.xhtml">Integrating with the Language Server Protocol</a> </li>
</ul>
</li>
<li>《Getting Started with LLVM Core Libraries》前端代码转换的部分
<ul>
<li><a href="https://getting-started-with-llvm-core-libraries-zh-cn.readthedocs.io/zh_CN/latest/">Getting Started with LLVM Core Libraries（中文版）</a></li>
</ul>
</li>
</ul>
<h3 id="debug"><a class="header" href="#debug">debug</a></h3>
<p>打印使用<code>llvm::outs() &lt;&lt; xxx;</code>直接打印llvm Value</p>
<h3 id="声明全局变量"><a class="header" href="#声明全局变量">声明全局变量</a></h3>
<p>Global variable definitions must be initialized.</p>
<p>Global variables in other translation units can also be declared, in which case they don’t have an initializer.</p>
<ul>
<li><code>dso_local</code> 看作是C语言的static，在同一个编译单元内</li>
</ul>
<p>LinkageTypes</p>
<ul>
<li><code>external</code> 是默认的，如果没有initializer就会带一个external，如果有就没有修饰符，正常的符号。</li>
</ul>
<h3 id="嵌套的指令-nested-instrucitons"><a class="header" href="#嵌套的指令-nested-instrucitons">嵌套的指令 nested instrucitons</a></h3>
<p>https://lists.llvm.org/pipermail/llvm-dev/2015-October/091467.html</p>
<p>使用IRBuilder创建的这个其实不是嵌套的指令，LLVM也不支持嵌套的指令，而是创建了GEP constant expression。这种表达式比指令更好，同时蕴含着没有副作用的语义。</p>
<h3 id="passmanger"><a class="header" href="#passmanger">PassManger</a></h3>
<p>LLVM PASS的管理有两种实现</p>
<ul>
<li>LegacyPass Manger</li>
<li>NewPass Manger</li>
</ul>
<p>传统的LegacyPM有一些不足，例如Analysis Pass不能缓存分析的信息导致重复分析等。NewPM将Analysis和Pass做了区分。在LegacyPM中存在过多的全局变量与registries，每个Pass都需要通过宏来注册，NewPM改进了这一点，当然还有内联函数分析等其他优化。LLVM12使用的是LegacyPassManager，13之后默认使用的是NewPassManager，<strong>本项目也使采用NewPassManager</strong>。</p>
<h3 id="运行与管理"><a class="header" href="#运行与管理">运行与管理</a></h3>
<p>LLVM API允许在应用程序中嵌入LLVM Pass，并将其作为库调用。</p>
<h3 id="调试"><a class="header" href="#调试">调试</a></h3>
<p>我们基于 vscode开发，使用codelldb插件。发现无法下条件断点。</p>
<ul>
<li>首先下普通断点</li>
<li>使用<code>breakpoint list</code> 查看断点编号</li>
<li>使用<code>breakpoint modify 1 -c &quot;((int64_t) (ci-&gt;getSExtValue()) &lt; -100)&quot;</code>这样的命令给断点增加条件</li>
</ul>
<p>更多使用方式见<a href="https://lldb.llvm.org/use/tutorial.html">lldb使用教程</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="notdec-development-document"><a class="header" href="#notdec-development-document">NotDec Development Document</a></h1>
<p>NotDec的项目文档。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webassembly-frontend"><a class="header" href="#webassembly-frontend">WebAssembly Frontend</a></h1>
<p>wasm frontend 负责将WASM字节码转为LLVM IR。</p>
<p>LLVM的好处就在于可以先生成比较差的IR，然后通过优化Pass不断修补。</p>
<h2 id="wasm-现有工具"><a class="header" href="#wasm-现有工具">WASM 现有工具</a></h2>
<ol>
<li>WAVM也是一个基于LLVM的带JIT功能的runtime。C++编写
<ol>
<li><code>WAVM\Lib\LLVMJIT\LLVMCompile.cpp</code> LLVMJIT::compileModule这个函数应该是编译入口点，很多可以参考。</li>
<li><code>WAVM\Lib\LLVMJIT\EmitFunction.cpp</code> EmitFunctionContext::emit 编译每个函数。关键是<code>decoder.decodeOp(*this);</code>这句，会根据不同的指令访问对应的同名函数，比如看<code>WAVM\Lib\LLVMJIT\EmitCore.cpp</code>，遇到block指令会调用EmitFunctionContext::block函数。</li>
</ol>
</li>
<li><a href="https://github.com/gwsystems/aWsm">aWsm</a> 也是一个基于LLVM的带JIT功能的runtime。虽然是rust写的，但是还是用的LLVM C++ API，转换相关的逻辑也都是可以抄的。</li>
<li>WAMR wasm-micro-runtime 基于LLVM的，但是是C语言，使用LLVM-C-API，我们打算用的是C++的API。
<ol>
<li>真的是自己写的字节码解析器好像。。。<a href="https://github.com/bytecodealliance/wasm-micro-runtime/blob/3220ff6941b64de684a5a60a5e3f8adad4a18fb0/core/iwasm/interpreter/wasm_loader.c">wasm_loader.c</a> <a href="https://github.com/bytecodealliance/wasm-micro-runtime/blob/3220ff6941b64de684a5a60a5e3f8adad4a18fb0/core/iwasm/interpreter/wasm.h">wasm.h</a></li>
<li>有相关wasm到LLVM IR的转换可以参考：<a href="https://github.com/bytecodealliance/wasm-micro-runtime/blob/c07584400134bb5f1be80b4f5df96eb1d8c94324/core/iwasm/compilation/aot_llvm_extra.cpp">aot_llvm_extra.cpp</a></li>
</ol>
</li>
</ol>
<h2 id="代码架构"><a class="header" href="#代码架构">代码架构</a></h2>
<ul>
<li>
<p>wasm模块解析器：基于wabt。<a href="https://github.com/WebAssembly/wasm-c-api">wasm-c-api</a>不太行因为是用来embed一个WASM VM的。</p>
<ul>
<li>目前直接通过</li>
<li>未来考虑通过find_package直接使用： https://github.com/WebAssembly/wabt/pull/1980</li>
</ul>
</li>
<li>
<p>首先由于最后都是转IR，所以BaseContext保存LLVM相关的Context。其实可以作为全局变量，为了以后可能的并行，把这类全局变量都搞到一个类里。</p>
</li>
<li>
<p>wasm::Context是相关生成的代码依附的数据结构，保存比如wabt::Module这种Context。为了方便应用，增加了对BaseContext的引用，对llvmCtx的引用等等。</p>
</li>
</ul>
<h2 id="specification"><a class="header" href="#specification">Specification</a></h2>
<p>需要了解LLVM IR的语义：</p>
<ol>
<li><a href="https://llvm.org/docs/LangRef.html">LLVM Language Reference Manual</a> </li>
<li><a href="https://www.youtube.com/watch?v=m8G_S5LwlTo">2019 EuroLLVM Developers’ Meeting: V. Bridgers &amp; F. Piovezan “LLVM IR Tutorial - Phis, GEPs ...” - YouTube</a> </li>
</ol>
<p>和WASM的语义：<a href="https://webassembly.github.io/spec/core/binary/modules.html">Modules — WebAssembly 2.0 (Draft 2022-09-27)</a> 注意现在直接翻标准是新release的2.0标准了。<strong>我们暂时先支持1.0标准</strong>，wabt现在也仅支持1.0，如果文件头里写version为2会报错。1.0的标准可以看<a href="https://www.w3.org/TR/wasm-core-1/#syntax-importdesc">这里</a>。
不确定每个指令的语义，看<a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Reference/Numeric/Negate">这种地方</a>。</p>
<ol>
<li>名字比较难处理，wasm的<a href="https://github.com/WebAssembly/extended-name-section/blob/main/proposals/extended-name-section/Overview.md">name section</a>允许重名，而且wasm中因为是二进制格式，理论上名字可以取任意utf-8。那边wat格式的定义也有类似的问题。但是wabt似乎已经处理了相关的问题？
<ul>
<li>在src\binary-reader-ir.cc里的BinaryReaderIR::GetUniqueName函数，如果重名了会加数字后缀。</li>
</ul>
</li>
<li>类型：i32 i64 对应LLVM中的i32 i64, f32 f64对应LLVM中的float double。</li>
<li>每个wasm的Global值转为llvm中一个的global值。相关访问只有Load和Store指令。
<ol>
<li>名字直接使用wabt那边传过来的名字 <del>名字更改为<code>global_&lt;ind&gt;_&lt;original_name&gt;</code>这种格式，即在原来名字前加上前缀标识。</del></li>
<li><a href="https://llvm.org/docs/LangRef.html#linkage-types">Linkage Types</a> 选择internal。被导出的更改为external。</li>
<li>根据mutable，设置llvm那边的const属性</li>
<li>处理init_expr</li>
</ol>
</li>
<li>内存：转为一个global数组，u8 array。
<ol>
<li>内存初始化：似乎LLVM IR里一个数组不能部分初始化。很多0也没办法。就这样吧</li>
<li>内存访问：计算关于u8的偏移（get element ptr），然后再转为对应的类型指针load出来。即LLVM中<code>[大数字 x i8]</code>类型。因为只是分析，所有不用考虑内存增长的事情。</li>
</ol>
</li>
<li>函数
<ol>
<li>每个Local转化为函数开头的一个alloca。</li>
<li><a href="https://webassembly.github.io/spec/core/exec/instructions.html#xref-syntax-instructions-syntax-instr-control-mathsf-call-indirect-x-y">非直接跳转 callind</a> </li>
</ol>
</li>
</ol>
<h2 id="指令栈控制流的处理"><a class="header" href="#指令栈控制流的处理">指令、栈、控制流的处理</a></h2>
<p>参考WAVM，见顶部现有工具一节。参考栈验证逻辑。能保留的最好直接解码为SSA。这里的block直接考虑<a href="https://github.com/WebAssembly/multi-value">Multi Value Extension</a>，防止以后架构需要重构，但是函数返回多个值的先不支持。</p>
<ul>
<li>每个栈上元素对应一个SSA的Value。某种形式上可以维护一个Value栈（作为局部变量，不需要作为Context）。</li>
<li>控制流跳转维护一个block的嵌套栈，保存br时跳转的目标。关键是如何在找到跳转目标的同时，把栈弹到对应的值。</li>
<li>处理Block的时候，这里用递归和用栈都可以。选择用实现起来更简单的递归。aWsm好像是递归的写法，WAVM好像是用栈，复杂一点。</li>
<li>loop和block的区别在于，给phi赋值，然后用Phi替换栈上值的地方不同。一个是基本块开头，一个是基本块结尾</li>
<li>函数体大致也算一个Block块，但是labelType写Func。</li>
</ul>
<h3 id="控制流指令的处理与ssa生成"><a class="header" href="#控制流指令的处理与ssa生成">控制流指令的处理，与SSA生成</a></h3>
<p>visitFunction：</p>
<ol>
<li>
<p>创建allocaBlock，分配参数和local空间</p>
</li>
<li>
<p>创建alloca -&gt; entry边，创建return块备用</p>
</li>
<li>
<p>调用visitBlock函数（visitBlock函数必须把所有的结束跳转都引导到exit块）</p>
</li>
<li>
<p>创建结尾的return指令。（visitBlock内部处理的时候只有br，return也看作特殊的br，函数只允许在结尾返回）</p>
</li>
</ol>
<p>递归的基本块生成算法visitBlock：
<strong>要求与保证</strong>：</p>
<ol>
<li>要求算法的整体表现类似于给定类型的单个指令</li>
<li>要求调用者提供的entry和exit中，需要创建Phi的那个为空基本块（但是可以有Phi指令），便于创建Phi节点。</li>
<li>保证结束的时候跳转到exit块。不会有其他控制流。</li>
</ol>
<p>注：</p>
<ol>
<li>没必要再用一个额外的stack防止访问更深元素，因为调用过了wabt的validate</li>
</ol>
<p>调用visitBlock前，根据block类型</p>
<ol>
<li>Block类型：创建新的exit块，替换原来exit，处理完毕后新的exit作为entry继续生成指令，旧的exit还是exit</li>
<li>Loop类型：创建新的entry块，替换原来entry。loop结束也一样。</li>
</ol>
<p>visitBlock：</p>
<ol>
<li>先创建好跳转目标，Phi节点，用这些设置好BreakoutTarget结构体，压入栈中：
<ol>
<li>根据是loop还是block类型的块创建Phi。如果是Loop，直接把当前栈上的值弹出来，作为phi的operand，然后把phi push回去，替换。如果是block，先创建空的Phi。（等后面结束的时候再从栈上加operand。</li>
<li>保存当前value栈的情况。</li>
</ol>
</li>
<li>依次遍历每个指令生成。
<ol>
<li>普通的指令根据指令语义，从value stack中取值，</li>
<li>如果遇到了跳转指令：
<ol>
<li>如果跳转的目标是普通基本块，则从栈上取值加入到对应的Phi中，</li>
</ol>
</li>
</ol>
</li>
<li>块结束的时候，不需要主动跳转到exit，因为exit不一定是当前block的exit，因为在Loop的情况下，结尾没有额外创建基本块，所以不需要特殊处理。Block结尾的跳转交给外面处理。</li>
<li>Block结束时，在end前，处理隐含跳转到结束块。由于类型检查，不会有多余的值，不需要unwinding弹出栈。</li>
</ol>
<p>控制流指令的处理：</p>
<ol>
<li>br指令，其后是stack可以是任何类型。为了处理这种情况，我们直接增加unreachable标识，无视这些指令。
<ul>
<li>对于Block</li>
<li>对于Loop，由于结尾是从Loop离开的唯一方式。如果有br指令封锁了结尾，则不可能从这个loop结尾离开了。此时直接保留UnReachableState</li>
</ul>
</li>
<li>block，loop分别对应在结尾，开头，增加一个label。注意到block只需要为return的值创建Phi，loop需要对参数创建Phi。</li>
<li>if对应一些label和br_if，br代表直接跳转，br_if同理，根据语义找到对应的跳转目标，生成条件跳转即可。</li>
<li>br_table看似比较麻烦，看了下和LLVM的switch语句对应得非常好啊。也是根据不同的值跳转到不同的边。</li>
</ol>
<p>最开始的时候先写一个类型检查，打印出每个指令后当前栈上的类型情况的代码，然后再加生成相关的东西。</p>
<p>wabt那边代表Block的结构体看wabt的<code>src\ir.h</code> 383行<code>struct Block</code>这边。</p>
<ul>
<li><code>std::string label</code> 直接放到BasicBlock的名字里面</li>
<li><code>BlockDeclaration decl</code> 和<code>FuncDeclaration</code>是一个类型</li>
<li><code>ExprList exprs</code></li>
<li><code>Location end_loc</code> 代表输入文件里的位置，暂时不管，除非后面想加debug信息</li>
</ul>
<p>多个参数和返回值的时候，顺序：</p>
<ul>
<li>函数参数逆序遍历（pop），同时从栈上pop出来。</li>
<li>函数返回值顺序遍历，同时push到栈上。</li>
</ul>
<p>查OpCode看<code>wabt/include/wabt/opcode.def</code>。Opcode和ExprType之间的关系看<code>src\lexer-keywords.txt</code>，或者看<code>wabt/src/lexer-keywords.txt</code>里面对应的Opcode创建了什么Expr，<del>或者看<code>src\binary-reader-ir.cc</code>里找对应的指令到底创建了哪种Expr类。</del></p>
<p>这里面的类继承关系看 <code>src\ir.h</code>。其实就是搞了一个ExprType，然后在onXXX指令的函数处直接创建了这个类型的Expr，导致opcode和expr之间没有明确的对应关系。</p>
<h2 id="运算指令的处理"><a class="header" href="#运算指令的处理">运算指令的处理</a></h2>
<ul>
<li>简单的可以对着这个找指令https://llvm.org/docs/LangRef.html。</li>
<li>可以找llvm intrinsic，例如fabs指令使用了对应的<code>Intrinsic::fabs</code></li>
<li>更复杂的可以自己手写llvm函数，然后直接调自己写的函数，之后看看要不要内联什么的</li>
</ul>
<p>资料：</p>
<ul>
<li>WAMR里，intrinsic的实现 https://github.com/bytecodealliance/wasm-micro-runtime/blob/d309091706f2fbfc3ccca2907226f57db4d612f3/core/iwasm/aot/aot_intrinsic.c</li>
<li>WAVM里，intrinsic的实现（使用irBuilder） https://github.com/WAVM/WAVM/blob/79c3aa29366615d9b1593cd527e5b4b94cc6072a/Lib/LLVMJIT/EmitNumeric.cpp</li>
</ul>
<h3 id="比较---浮点数"><a class="header" href="#比较---浮点数">比较 - 浮点数</a></h3>
<p>参照https://www.w3.org/TR/wasm-core-1/#-hrefop-feqmathrmfeq_n-z_1-z_2 和https://llvm.org/docs/LangRef.html#id309 对比语义</p>
<ol>
<li>feq在wasm中，如果有nan就返回0，反过来只有无nan才返回true，所以采用<code>fcmp oeq</code>。</li>
<li>而fne，有nan就返回1，所以要用<code>fcmp une</code></li>
</ol>
<h3 id="simd"><a class="header" href="#simd">SIMD</a></h3>
<p>参照 https://github.com/WebAssembly/simd/blob/master/proposals/simd/SIMD.md
指令 https://github.com/zeux/wasm-simd/blob/master/Instructions.md
https://nemequ.github.io/waspr/instructions</p>
<h4 id="指令格式"><a class="header" href="#指令格式">指令格式</a></h4>
<p><code>{interpretation}.{operation}</code> </p>
<p>前缀<code>{interpretation}</code>表示如何解释 v128 类型的字节：格式为<code>{t}{lane_width}x{n}</code></p>
<ul>
<li>t是类型: v（只划分不解释）/i（整形）/f（浮点）</li>
<li>lane_width是lane位宽：8/16/32/64</li>
<li>n是lane总数</li>
</ul>
<h4 id="处理"><a class="header" href="#处理">处理</a></h4>
<ol>
<li>默认的v128在LLVM IR中被定义为<code>&lt;2 x i64&gt;</code> 类型。</li>
<li>Wasm指令中的vector操作数都是v128类型，<code>{interpretation}</code>则是指令执行和执行完的向量类型，所以需要使用BitCast进行转换。过多的BitCast显得很繁杂，参考了WAVM使用宏定义来简化代码。</li>
<li>LLVM中的Intrinsic对vector支持很好，直接转换好数据类型后调用对应的Intrinsic即可。</li>
<li>有些指令设计向量的缩减与扩增，可以用Shuffle配合mask来实现。</li>
</ol>
<h3 id="链接"><a class="header" href="#链接">链接</a></h3>
<ul>
<li>WebAssembly Object File Linking： https://github.com/WebAssembly/tool-conventions/blob/main/Linking.md</li>
<li>Adventures in WebAssembly object files and linking： https://mike.zwobble.org/2021/04/adventures-in-webassembly-object-files-and-linking/</li>
</ul>
<p>相关section的解析可以看<code>src\binary-reader.cc</code>里的<code>BinaryReader::ReadCustomSection</code>函数。</p>
<h2 id="测试"><a class="header" href="#测试">测试</a></h2>
<ol>
<li>基于sysY语言的测试用例，自动编译为wasm和wat格式，反编译到IR后和sylib.c得到sylib.ll一起输入lli执行。验证输出的正确性。
<ul>
<li>使用-c编译为未链接的object ？
<ul>
<li>缺点1：内存是导入的，大小不确定</li>
<li>缺点2：需要处理额外的。</li>
</ul>
</li>
<li>编译为完整模块，加上<code>-g -O0 --no-standard-libraries -Wl,--export-all -Wl,--no-entry -Wl,--allow-undefined</code>等选项。全部导出可以不用特殊处理main函数的导出，allow undefined好像会让没定义的都变成导入。
<ul>
<li>目前暂时的方案。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="其他-1"><a class="header" href="#其他-1">其他</a></h2>
<h3 id="wasm中的函数指针调用复习"><a class="header" href="#wasm中的函数指针调用复习">Wasm中的函数指针调用（复习）</a></h3>
<p>在二进制模块中有id为4的table section。里面有一系列的table类型，初始化则由element section负责。table类型有两部分，reftype和limit。<a href="https://webassembly.github.io/spec/core/binary/types.html#limits">limit</a>应该是类似数组大小的东西，但是同时包含了上限和下限。</p>
<p>reftype其实就是个enum，表示是不透明的external类型还是function类型。即，光是table section里，有用的信息只有定义了index，给每个index处的table标明了上下限。</p>
<p>reference类型是和其他类型独立的。即真的无法观测到底是怎么表示的，只能被存在table里。即和程序call指令里面用的index不同。其实我们只要管func ref，external ref一般指不是函数的情况。如果有的话直接那个吧。</p>
<p>接下来看elem section。它可以是passive的，即等着被table.init指令使用，用来初始化某个table。或者是active的，直接初始化某个table。最后可以是declarative的，说是前向声明。（TODO，不是特别理解）</p>
<p>现在直接翻标准是新release的2.0标准了。我们暂时先支持1.0标准里面流行的active类型的elem。（wabt现在如果文件头里写version为2会报错。（这个version是在整个二进制模块的header处定义的。）但是依然支持这一部分的新格式，可能是以支持相关拓展的形式实现的）</p>
<p>首先介绍<a href="https://webassembly.github.io/spec/core/binary/modules.html#element-section">标志位</a>：</p>
<ul>
<li>bit0: passive 或 active 的标志位。</li>
<li>bit1: 分两种情况
<ul>
<li>active: 存在额外的table index。（否则默认是0） </li>
<li>标志位表示是passive或者declarative。</li>
</ul>
</li>
<li>bit2: bit 2 indicates the use of element type and element expressions instead of element kind and element indices.</li>
</ul>
<p>elem section由三部分组成：</p>
<ol>
<li>table index, 初始化哪个table。目前因为只有一个table，所以必须是0。</li>
<li>offset, 常量表达式，即一些指令。例如：<code>41 01 0b</code>解码为<code>i32.const 1; end;</code>。</li>
<li>vec(func ind) 一系列函数下标，表示要初始化成这些。</li>
</ol>
<p><a href="https://www.wasm.com.cn/docs/future-features/">Features to add after the MVP - WebAssembly 中文网|Wasm 中文文档</a> https://www.w3.org/TR/wasm-core-1/#element-segments%E2%91%A0 （可以在这个页面搜索<code>at most one</code>） 这里提到了，MVP标准中wasm最多有一块内存，最多有一个table。</p>
<p>对应到LLVM IR的关键是，相同的语言特性会怎么在LLVM IR上实现/怎样的LLVM IR会编译到这样的wasm。LLVM里只有Call指令，但是参数是一个函数地址的value。目前看来可以搞一个函数指针数组，对应初始化后的table。然后将callind翻译为从函数指针中取，然后再call。</p>
<p>至于非直接跳转，由于和llvm的switch完美对应，就非常简单。br_table指令会带有个table，让index从1到table的大小遍历，根据当前栈上的值是否等于当前index，从table里面取出要跳转的层数，找到对应的基本块，为switch增加跳转目标即可。</p>
<h2 id="todo-1"><a class="header" href="#todo-1">TODO</a></h2>
<p>最好能实现单个函数的反编译与混淆，即转换回Wasm时最好能保证其他部分不变。。。如果使用LLVM自己的wasm后端好像有点复杂</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docs-of-optimizers"><a class="header" href="#docs-of-optimizers">Docs of optimizers</a></h1>
<p>项目使用LLVM Pass框架来进行反编译中的中间代码优化。</p>
<h2 id="相关资料"><a class="header" href="#相关资料">相关资料</a></h2>
<p>入门教程<a href="https://github.com/banach-space/llvm-tutor">banach-space/llvm-tutor: A collection of out-of-tree LLVM passes for teaching and learning (github.com)</a></p>
<p>中文文章[<a href="https://bbs.kanxue.com/thread-257665.htm">翻译]现代化地编写LLVM Pass -- part I-外文翻译-看雪论坛-安全社区|安全招聘|bbs.pediy.com (kanxue.com)</a></p>
<h2 id="变量识别"><a class="header" href="#变量识别">变量识别</a></h2>
<p>清除IR中的全局栈指针，并对其使用处的指令操作数(局部变量地址)进行转换，转换为对alloca里的东西的使用，把对mem0的使用，其中的使用mem0的栈部分，改为使用我们的alloca。
参考<a href="https://github.com/avast/retdec/blob/master/src/bin2llvmir/optimizations/stack/stack.cpp">retdec/stack.cpp</a></p>
<ul>
<li>识别并消除函数开头和结尾的栈指针操作</li>
<li>把对mem0的取下标+load/store操作，根据全局变量还是局部变量，转变为（新创建的）局部变量或者全局变量的操作。</li>
</ul>
<p>变量分为全局变量，局部变量，堆变量，堆变量一般直接调函数分配，暂时不考虑。</p>
<ul>
<li>全局变量的访问：对mem0取下标的这个值是常量（范围大致在1024到一个很大的值之间）【可能存在偏移运算】</li>
<li>局部变量的访问：对mem0取下标的值，是栈指针（取global 0）【可能存在偏移运算】</li>
<li>也可能直接把地址存入变量里，即取地址。</li>
</ul>
<p>其中偏移运算可能是常量也可能是变量，是变量时甚至可能存在乘法运算。
（如果把栈指针存到了结构体里怎么办？假装它没有定义结构体，定义了很多零散的变量？）结构体的问题在于，成员地址可能基于结构体自身的指针计算得到</p>
<ul>
<li>如何判断global0是不是栈指针</li>
<li>如何匹配函数开头的栈指针的sub操作</li>
<li>如何判断哪些值是栈内存的指针</li>
</ul>
<h3 id="挑战"><a class="header" href="#挑战">挑战</a></h3>
<p>现在内存不是直接访问的：即load和store指令会在加载和保存的时候，将偏移加上mem0的基地址。但是，如果一旦引入了类似于直接alloca的这种情况，则它将是直接地址，而不是直接加上mem0的基地址。问题在于，可能会有指针混指的情况，即可能指向全局变量或者栈空间变量。这样在后面load/store的时候，无论是加上mem0的基址还是不加都有问题。</p>
<p>因此引入地址空间的概念，引入数值和地址的转换符。</p>
<p>能否保证语义安全？因为我们现在转出来的IR是能跑的，如果变量恢复后，是不是就不能跑了？比如部分变量识别失败，还是存到mem里去了。</p>
<h3 id="实现"><a class="header" href="#实现">实现</a></h3>
<p>wasm解析为IR后先优化一下。</p>
<h4 id="如何判断哪些值是栈内存的抽象解释算法"><a class="header" href="#如何判断哪些值是栈内存的抽象解释算法">如何判断哪些值是栈内存的&quot;抽象解释&quot;算法</a></h4>
<p>和传统的数据流分析不同的地方在于，LLVM是SSA形式，每个值只有一个赋值点。因此，一个值要么是栈指针，要么不是。因此只需要直接循环迭代。但是LLVM里还是有变量，即alloca出来的值，可能因为控制流的跳转而来自不同的取值，从而导致基于变量计算出来的值，依赖于这个变量是不是和栈指针有关的东西。</p>
<p>要分析清楚对mem0取下标的这个值，是不是来自stackpointer的运算。</p>
<ol>
<li>一定来自stack pointer</li>
<li>可能来自stack pointer</li>
<li>一定不来自stack pointer</li>
</ol>
<p>为每个llvm的Value维护一个bool类型变量表示是否是栈指针。
遍历所有基本块（可能拓扑排序会高效一点），直到某次完全遍历也没有任何变化
初始化：算法开始前已经判断了函数开头的栈指针值，对应的bool设置为true
如果遇到了运算，任意一个输入值对应true的话，结果也设置为true。</p>
<p>把变量也标为是栈指针类型？所有对这个变量的load都是栈指针？</p>
<p>union怎么办？先不考虑。</p>
<p>目前的解决方法：
遇到内存访问指令沿着use-def向上回溯，构造一条chain 看是否可达sp,如果可达，那么就是栈地址，并把它放在栈相关集合中。
如果存进去的值也是栈地址，那么就把对应偏移的放在另一个栈相关集合中。</p>
<p>TODO:</p>
<p>1.需要实现过程间分析，如果call指令的参数和返回值都是栈地址，需要把它们放到栈相关集合中。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ghidra"><a class="header" href="#ghidra">Ghidra</a></h1>
<h2 id="资源"><a class="header" href="#资源">资源</a></h2>
<p>其他资源列表：</p>
<ul>
<li><a href="https://low-level.readthedocs.io/en/latest/reversing/ghidra/">Ghidra - low level</a> 这里有很多其他资源，dump local variables的脚本。和搭建调试环境的issue链接。</li>
<li><a href="https://github.com/AllsafeCyberSecurity/awesome-ghidra">Awesome Ghidra</a></li>
</ul>
<p>书籍：</p>
<ul>
<li>《THE GHIDRA BOOK The Definitive Guide》 TheGhidraBook.pdf</li>
<li>《Ghidra Software Reverse Engineering for Beginners》 有pdf</li>
</ul>
<p>使用教程：</p>
<ul>
<li>Ghidra API的tutorial：https://github.com/HackOvert/GhidraSnippets</li>
<li>Dump出high-pcode的教程 https://github.com/HackOvert/GhidraSnippets#dumping-refined-pcode </li>
<li>基于Ghidra实现的VSA：https://github.com/penhoi/ghidra-decompiler/wiki/Symbolic-Value-Set-Analysis </li>
<li>如何开发调试Ghidra：https://spinsel.dev/2021/04/02/ghidra-decompiler-debugging.html 这人也</li>
</ul>
<p>代码分析：</p>
<ul>
<li><a href="https://conference.hitb.org/hitbsecconf2021sin/materials/D1T2%20-%20Taking%20Ghidra%20to%20The%20Next%20Level%20-%20Zhanzhao%20Ding.pdf">《Ghidra To The Next Level》</a> 丁湛钊的介绍 这个slides讲了不少ghidra的反编译器的设计。</li>
<li><a href="https://www.freebuf.com/articles/network/278014.html">《记一次对Ghidra反编译的修复》</a>解释了反编译原理，里面解决的问题其实就是栈变量识别相关的 </li>
<li><a href="https://github.com/NationalSecurityAgency/ghidra/blob/master/DevGuide.md">DevGuide.md</a> 官方的eclipse环境搭建</li>
<li><a href="https://research.nccgroup.com/2022/05/20/earlyremoval-in-the-conservatory-with-the-wrench/">《Exploring Ghidra’s decompiler internals to make automatic P-Code analysis scripts》</a>解释了一些decomp_dbg的代码。</li>
</ul>
<h3 id="ghidra-sleigh-调试环境搭建"><a class="header" href="#ghidra-sleigh-调试环境搭建">Ghidra-sleigh 调试环境搭建</a></h3>
<p>相关的C/C++代码主要在 Ghidra/Features/Decompiler/src/decompile.cpp下。docmain.hh和 doccore.hh两个文件可以先看，或者先build doc出来，生成的doc在<code>../doc</code>目录（Ghidra/Features/Decompiler/src/decompile/doc/html/index.html）</p>
<p>根据这里https://daniao.ws/notes/quick-tips/build-ghidra 下载并编译Ghidra。生成各种中间文件</p>
<pre><code class="language-Bash">sudo apt install openjdk-17-jdk-headless unzip --no-install-recommends
wget -c https://services.gradle.org/distributions/gradle-8.1.1-bin.zip -P /tmp
sudo unzip -d /opt/gradle /tmp/gradle-8.1.1-bin.zip
export PATH=$PATH:/opt/gradle/gradle-8.1.1/bin
echo 'export PATH=$PATH:/opt/gradle/gradle-8.1.1/bin' &gt;&gt; ~/.bashrc

git clone https://github.com/NationalSecurityAgency/ghidra.git
git checkout Ghidra_10.3.1_build
git checkout -b mydev
gradle --init-script gradle/support/fetchDependencies.gradle init
gradle buildGhidra
</code></pre>
<p>然后vscode打开文件夹<code>/home/ubuntu/ghidra/Ghidra/Features/Decompiler/src/decompile</code></p>
<p>使用bear生成compile_commands.json文件</p>
<pre><code class="language-Bash">bear -- make decomp_dbg
</code></pre>
<p>增加debug配置。注意里面的环境变量指向ghidra源码文件夹</p>
<pre><code class="language-JSON">{
    &quot;version&quot;: &quot;0.2.0&quot;,
    &quot;configurations&quot;: [
        {
            &quot;type&quot;: &quot;lldb&quot;,
            &quot;request&quot;: &quot;launch&quot;,
            &quot;name&quot;: &quot;Debug&quot;,
            &quot;program&quot;: &quot;${workspaceFolder}/cpp/decomp_dbg&quot;,
            &quot;args&quot;: [],
            &quot;cwd&quot;: &quot;${workspaceFolder}/datatests&quot;,
            &quot;env&quot;: {&quot;SLEIGHHOME&quot;: &quot;/home/ubuntu/ghidra&quot;}
        }
    ]
}
</code></pre>
<p>从ghidra图形界面，反编译的右上角的debug decompiler里面可以导出xml文件，用于调试。</p>
<h3 id="调试与decomp_dbg常用命令"><a class="header" href="#调试与decomp_dbg常用命令">调试与decomp_dbg常用命令</a></h3>
<p>https://github.com/NationalSecurityAgency/ghidra/issues/720</p>
<pre><code class="language-JSON">load file test 加载二进制文件
load addr 0x1149
decompile
print C

restore Reset.xml    加载xml文件
trace address
trace list
</code></pre>
<p>搜索相关的命令：<code>registerCommands</code> <code>registerCom</code> </p>
<p>部分命令需要<code>OPACTION_DEBUG</code>开启</p>
<h2 id="反编译器代码解读sleigh"><a class="header" href="#反编译器代码解读sleigh">反编译器代码解读（sleigh）</a></h2>
<p><strong>总体分析流程</strong></p>
<p>Ghidra的Java部分代码启动sleigh子进程，然后通过stdin输入xml文件，stdout读取xml文件作为反编译结果。比如Ghidra\Features\Decompiler\src\main\java\ghidra\app\decompiler\DecompileResults.java parseRawString函数这里开始解析反编译器的输出的。Ghidra\Framework\SoftwareModeling\src\main\java\ghidra\program\model\pcode\HighFunction.java readXML函数里可以看到high pcode是基于这个ast的标签解析的。</p>
<p>反编译输出展示上面的选项里，选Debug Function Decompilation导出的xml文件是反编译器的输入。根据https://github.com/NationalSecurityAgency/ghidra/issues/720 这里可以使用decomp_dbg命令行输入xml文件进行反编译。</p>
<p>应该反编译过程中，Pcode都是一套Pcode，只不过https://spinsel.dev/assets/2020-06-17-ghidra-brainfuck-processor-1/ghidra_docs/language_spec/html/additionalpcode.html 有一些额外的东西只有在反编译之后才会产生。</p>
<p><strong>反编译阶段</strong></p>
<p>首先反编译过程被分为了几个大的 <code>simplification styles</code> <code>Root Action Groups</code>。它们由 <code>base groups</code> （例如 “stackvars” or “typerecovery”） 组成。</p>
<ul>
<li>decompile – The main decompiler action</li>
<li>normalize – Decompilation tuned for normalization</li>
<li>jumptable – Simplify just enough to recover a jump-table</li>
<li>paramid – Simplify enough to recover function parameters</li>
<li>register – Perform one analysis pass on registers, without stack variables</li>
<li>firstpass – Construct the initial raw syntax tree, with no simplification</li>
</ul>
<p>在<a href="https://github.com/NationalSecurityAgency/ghidra/blob/Ghidra_10.1.2_build/Ghidra/Features/Decompiler/src/decompile/cpp/coreaction.cc#L5021-L5275">universalAction</a>函数里构建了所有可能的Action和Rule列表，即定义了他们的执行顺序。每个Action或Rule是否运行再由标签确定。</p>
<p><a href="https://github.com/NationalSecurityAgency/ghidra/blob/Ghidra_10.3.1_build/Ghidra/Features/Decompiler/src/decompile/cpp/action.hh#L194">Rule</a>: 代表着某个特定的点位可能采取的操作。它输入一个Pcode位置，首先判断能不能在该处应用，然后再应用更改。Rule可以通过<code>getOpList()</code>函数先给出一个点位可能的Opcode列表，方便外部提前过滤。多个Rule可以组合为<code>ActionPool</code></p>
<p><a href="https://github.com/NationalSecurityAgency/ghidra/blob/Ghidra_10.3.1_build/Ghidra/Features/Decompiler/src/decompile/cpp/action.hh#L52">Action</a> 类似Pass，对一个函数做变换。每次变换递增一下count变量。</p>
<p>和栈分析相关的标签：<code>localrecovery</code> <code>typerecovery</code> <code>stackvars</code></p>
<p>和栈分析相关的标签，和内部的Action和Rule：</p>
<p><code>base</code></p>
<ul>
<li>ActionHeritage SSA构建算法。</li>
</ul>
<p><code>localrecovery</code>
- ActionRestrictLocal: 限制局部变量在栈上的可能范围，排除一些参数之类的栈范围，使得这些范围不会创建局部变量。
- 首先对每个FunctionCallSpecs，的每一个参数，把它们的地址排除在局部变量之外。
- 对保存的caller的寄存器，相关的栈内存排除在局部变量之外。
- 注：可见wasm里不用管这些。
- ActionRestructureVarnode
- gatherVarnodes：从varnode中收集栈上值的类型信息。它遍历funcdata在stack这个space上的Varnode，然后在对应的栈偏移处增加当前varnode的类型信息，表示为增加一个RangeHint
- gatherOpen：先调用 AliasChecker::gather，收集一个AddBase的list，包含所有的栈相关指针，然后对每个指针调用gatherOffset, 收集偏移。最后会设置一个aliasBoundary为最小的offset，可能比它大就可能alias。
- AliasChecker::gather：对于给定的函数和address space（栈），收集所有，指向当前地址空间的，指针（varnode）。
- AliasChecker::gatherAdditiveBase：首先从栈指针开始，收集所有和它有关的加法操作（INT_ADD, INT_SUB, PTRADD, PTRSUB, and SEGMENTOP）。广度优先地遍历，vnqueue作为worklist。最后生成了AddBase的一个list，表示每个有关的root varnode和可能存在的index varnode。
- gatherOffset：对每个收集的AddBase的base调用，负责计算出varnode的常量offset
- gatherSymbols：
- ScopeLocal::restructure：</p>
<p><code>stackvars</code>
- RuleLoadVarnode
- RuleStoreVarnode</p>
<p><code>stackptrflow</code>
- ActionStackPtrFlow
- <code>checkClog</code>: Clog是指，栈指针加栈上的值？
- <code>analyzeExtraPop</code>: sub-functions TODO，难道是说子函数里面用父函数栈指针？</p>
<p>decomp_dbg 代码位于consolemain.cc（main 函数，也定义了 load/save/restore几条命令）、ifacedecomp.hh/cc （反编译相关命令）。</p>
<ul>
<li>Heritage::discoverIndexedStackPointers</li>
</ul>
<p>通过一通搜索，我找到了restructure varnode这个action，发现了一些问题。这个action的主要工作就是调用 ScopeLocal::restructureVarnode函数（varmap.hh/cc)，这个函数的工作分配给了 MapState::gatherVarnodes 、MapState::gatherOpen 和 MapState::gatherSymbols ，最后调用了ScopeLocal::restructure。</p>
<p>其中有关的部分在gatherOpen和gatherVarnodes。gatherOpen在正常情况下，应该分析出好几段栈空间对应的 open RangeHint ，其中的处理逻辑在AliasChecker::gather -&gt; AliasChecker::gatherInternal -&gt; AliasChecker::gatherAdditiveBase 。</p>
<p>MapState::gatherVarnodes</p>
<p>所以，我将范围扩大到在heritage 、restructureVarnodes action之后，然后找到了相关的action ：RuleLoadVarnode和 RuleStoreVarnode。</p>
<p>这两个action（其实是Rule）应该就是分析的主要了，他们都会经过RuleLoadVarnode::checkSpacebase -&gt; RuleLoadVarnode::vnSpacebase -&gt; RuleLoadVarnode::correctSpacebase (ruleaction.cc) 的检查。调试发现，没能分析出来的变量所对应的 store/load在correctSpacebase的检查中失败了 。</p>
<p>这两个action（其实是Rule）应该就是分析的主要了，他们都会经过RuleLoadVarnode::checkSpacebase -&gt; RuleLoadVarnode::vnSpacebase -&gt; RuleLoadVarnode::correctSpacebase (ruleaction.cc) 的检查。调试发现，没能分析出来的变量所对应的 store/load在correctSpacebase的检查中失败了。</p>
<p>ActionDatabase::buildDefaultGroups 分析好像是分组的，里面很多rule。</p>
<p>“simplification styles” are also referred to as “root actions” or “groups” in the decompiler source code. They consist of groups of “base groups” such as “stackvars” or “typerecovery”, which are more fine-grained groups of specific analysis operations.</p>
<h3 id="ghidra-中的-value-set-analysis"><a class="header" href="#ghidra-中的-value-set-analysis">Ghidra 中的 value set analysis</a></h3>
<ul>
<li><a href="https://github.com/NationalSecurityAgency/ghidra/blob/Ghidra_10.3.1_build/Ghidra/Features/Decompiler/src/decompile/cpp/rangeutil.hh#L274"><code>ValueSetSolver</code></a> VSA分析。好像会先执行<code>vsSolver.establishValueSets</code>给要分析的值赋初始值，然后调用<code>vsSolver.solve</code>运算。
<ul>
<li><code>CircleRange</code>: 底层抽象域，针对不同opcode写了运算，例如<code>CircleRange::pushForwardBinary</code>负责binary op</li>
<li>使用方面，有两个使用点：一个<code>IfcAnalyzeRange</code>好像是执行<code>analyze range full|partial &lt;varnode&gt;</code>命令的时候触发。另外一个是<code>ValueSetSolver.analyzeNewLoadGuards</code>函数，为LoadGuard确认访问范围。</li>
</ul>
</li>
<li><code>LoadGuard</code>: 对一个，访问了栈，但是是在动态访问栈的load指令的描述。描述其可能访问的栈范围。包括min, max, step等。和VSA分析有很大关系。</li>
</ul>
<h2 id="编写插件"><a class="header" href="#编写插件">编写插件</a></h2>
<h3 id="ghidra-scripting"><a class="header" href="#ghidra-scripting">Ghidra scripting</a></h3>
<ul>
<li>
<p>命令行直接加载二进制文件，可以设置分析后是否保存
https://static.grumpycoder.net/pixel/support/analyzeHeadlessREADME.html#scripting_headlessScripts_controlProgramDisposition </p>
</li>
<li>
<p>如何遍历定义的结构体成员
https://reverseengineering.stackexchange.com/questions/21320/automate-looking-for-calls-to-an-offset-of-a-structure</p>
<p><code>structure.getDefinedComponents</code> <code>Ghidra\Framework\SoftwareModeling\src\main\java\ghidra\program\model\data\CompositeInternal.java</code> 的dumpComponents方法是结构体转string的时候用到的。</p>
</li>
<li>
<p>获取创建符号
getSymbols(name, namespace)</p>
</li>
<li>
<p>获取和创建函数
FlatAPI的getFunction系列。按照namespace获取函数是在listing里：getCurrentProgram().getListing()</p>
<p>Flatapi的createFunction。更多创建函数在FunctionManager：getCurrentProgram().getFunctionManager().createFunction</p>
<p>getCurrentProgram().getExternalManager().addExtFunction好像同时会创建External Location和对应的函数？</p>
</li>
<li>
<p>指定地址寻找函数
看了下flat program api里面对getFirstFunction和getFunctionAfter的实现，发现就是currentProgram.getListing().getFunctions函数的简单调用。而且getFunctionAfter还有传入地址和函数的版本。</p>
</li>
<li>
<p>设置函数签名
FunctionSignatureParser负责的就是修改函数的时候，上面那个输入框的解析。</p>
<p>FunctionEditorModel这个类负责这个输入框背后的逻辑：调用上述parser，得到FunctionDefinitionDataType，然后调用自身的setFunctionData函数。函数内部设置函数的参数和返回值。</p>
</li>
<li>
<p>偏移找寄存器
<code>\ghidra_10.1.2_PUBLIC\Ghidra\Processors\ARM\data\languages\ARM.sinc</code>看这个文件</p>
</li>
<li>
<p>设置/读取寄存器值
https://ghidra.re/ghidra_docs/api/ghidra/program/model/listing/ProgramContext.html </p>
<p>program.getProgramContext().setValue(register, start, end, value); 一般可以start=end=想要的地址</p>
<p>Ghidra\Features\Base\src\main\java\ghidra\app\util\viewer\field\RegisterFieldFactory.java getRegisterStrings好像是负责写assume xxx = xxx的。</p>
<p>Ghidra\Features\Base\src\main\java\ghidra\app\util\viewer\field\RegisterFieldFactory.java getSetRegisters负责获取设置的寄存器</p>
</li>
<li>
<p>加载头文件报错的常见解决方法
在parse C source界面之所以会标红，应该是要自己在下面的-I选项给出这些头文件存在的位置。比如我的-IC:\Program Files\LLVM\lib\clang\13.0.0\include</p>
<p>-IC:\Program Files (x86)\Dev-Cpp\MinGW64\lib\gcc\x86_64-w64-mingw32\4.9.2\include</p>
<p>目前用到size_t的还真的不知道怎么办。上面两个头文件处理后都不太行，变成typedef <strong>SIZE_TYPE</strong> size_t;这种，而且完全看不到int32_t的定义。所以windows下的头文件不太行。还是得看看。最后从wsl里复制header出来，在x86_64-linux-gnu\bits\types.h这里定义了。但是我include好像没用，不知道为什么</p>
<p>TODO：暂时放弃，直接使用types里面复制处理的。</p>
<pre><code class="language-c">#define __stdcall
struct va_list; // shitty hack
typedef struct va_list *va_list;

typedef long int ptrdiff_t;
typedef long unsigned int size_t;
</code></pre>
<p>有些可以直接用-D参数的方式解决。-D甚至可以定义函数式宏：https://stackoverflow.com/questions/31857559/gcc-define-function-like-macros-using-d-argument </p>
<p>-D__attribute__(x)= 好像没有用，但是ghidra好像能直接识别，不会报这个的错</p>
<pre><code class="language-c">-Dsize_t=&quot;unsigned long&quot;

/* Fixed-size types, underlying types depend on word size and compiler.  */
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
#if __WORDSIZE == 64
typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;
#else
__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;
#endif
</code></pre>
</li>
</ul>
<h4 id="memoryblock"><a class="header" href="#memoryblock">MemoryBlock</a></h4>
<p>原来没有直接的方法，是通过创建新Block然后调用join方法。</p>
<p><code>Ghidra\Features\Base\src\main\java\ghidra\app\plugin\core\memory\ExpandBlockModel.java</code> applyTo函数</p>
<ul>
<li>
<p>读写内存区域
Uninitialized的内存默认是不能写的，需要把要写的部分分割开，然后设置成initialized。</p>
<p>https://github.com/NationalSecurityAgency/ghidra/issues/3585 </p>
</li>
<li>
<p>动态链接与Thunk Function</p>
<p>ThunkFunction corresponds to a fragment of code which simply passes control to a destination function. All Function behaviors are mapped through to the current destination function. 另外thunk不需要设置参数和返回值类型，直接复制的目标对象的类型。</p>
<p>主要的逻辑在Ghidra\Features\Base\src\main\java\ghidra\app\util\opinion\ElfProgramBuilder.java这里。当加载程序的时候，它会处理各种符号。单是创建单独的external符号是在“<EXTERNAL>”（Library.UNKNOWN）这个库下的，默认没有map到内存中，所以getExternalSpaceAddress这里是一种Fake的地址。而内存中的“EXTERNAL”（MemoryBlock.EXTERNAL_BLOCK_NAME）是ElfProgramBuilder创建的。（通过搜索NOTE: This block is artificial and is used to make relocations work correctly找到的）</p>
<p>为什么他创建的thunk方法可以不在listring的Function里显示，秘诀大概是：getCurrentProgram().getSymbolTable().removeSymbolSpecial。参照下面文件里搜索removeSymbolSpecial的代码。</p>
<p>分配单独的一块内存创建EXTERNAL块相关的逻辑在Ghidra\Features\Base\src\main\java\ghidra\app\util\opinion\ElfProgramBuilder.java allocateLinkageBlock函数。</p>
</li>
</ul>
<h3 id="查看high-p-code"><a class="header" href="#查看high-p-code">查看high p-code</a></h3>
<p>https://reverseengineering.stackexchange.com/questions/29646/dump-pcode-in-ghidra-for-a-specific-decompiled-function 直接在界面点就可以，但是好像只是为了给你看形状的。打开python然后currentLocation.token.pcodeOp也可以稍微看看当前指针位置的。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="retdec"><a class="header" href="#retdec">RetDec</a></h1>
<p>https://zhuanlan.zhihu.com/p/509763117 有一些源码解读的内容。</p>
<ul>
<li>retdec的4.0是最后一个包含单独的ir转c工具的版本。相关代码<code>src/llvmir2hlltool/CMakeLists.txt</code> (要先checkout到v4.0。)</li>
<li>能否直接把ir传给</li>
</ul>
<h3 id="开发环境"><a class="header" href="#开发环境">开发环境</a></h3>
<p>在cmake配置里增加&quot;-DCMAKE_INSTALL_PREFIX=/home/xx/retdec/build/retdec-install&quot;，然后直接使用cmake插件，目标选择install。（因为retdec-decompile工具需要找到decompiler-config.json文件，因此需要安装）</p>
<h4 id="入口函数"><a class="header" href="#入口函数">入口函数</a></h4>
<ul>
<li>retdec-decompiler.cpp 主要是解压，脱壳什么的，然后调用retdec::decompile函数。这里的retdec是namespace，不是class，所以就在src/retdec/retdec.cpp。</li>
<li>其中非常重要的是读取share/retdec/decompiler-config.json，其中有llvmPasses这一项，指定了一系列pass名字。然后在那边retdec::decompile函数，他会根据config.parameters.llvmPasses里的值找到pass，然后依次加入passmanager里。然后pm.run(*module);运行结束之后，一切反编译过程都完成了。</li>
</ul>
<h4 id="pass功能"><a class="header" href="#pass功能">Pass功能</a></h4>
<p>vscode代码搜索方法：基于<code>src/retdec-decompiler/decompiler-config.json</code>，对每个pass的名字带双引号搜索。比如搜<code>&quot;retdec-decoder&quot;</code></p>
<ul>
<li>retdec-provider-init： 这个pass负责给很多Provider类设置信息（到静态变量里）。FileImageProvider，DebugFormatProvider，DemanglerProvider等等。如果我们要设置一下简单的，可以直接在Pass运行前加。</li>
<li>retdec-decoder：<code>src/bin2llvmir/optimizations/decoder/decoder.cpp</code> 负责把capstone的结果转成IR。</li>
<li>&quot;retdec-x86-addr-spaces&quot;：把一些对FS，GS寄存器寻址的访问转成intrinsic call，如<code>getReadFsByte</code></li>
<li>retdec-x87-fpu: replace fpu stack operations with FPU registers</li>
<li>retdec-main-detection: 识别出main函数之后，也就是（在retdec自己的config里）重命名了一下。</li>
<li>retdec-idioms-libgcc：把一些libgcc的算数运算替换成LLVM里的运算。</li>
<li>retdec-idioms：把常见的指令组合替换成别的指令？</li>
<li>retdec-inst-opt：好像是简单的窥孔优化。</li>
<li>retdec-inst-opt-rda</li>
<li>retdec-cond-branch-opt 这些优化应该不用</li>
<li>retdec-syscalls：好像是把系统调用转成对应的call？有一个map</li>
<li>**retdec-stack：**关键Pass，识别栈指针相关的操作。</li>
<li>retdec-constants：好像是识别常量的类型的。看不懂。里面好像有根据debuginfo，获取data段变量类型。</li>
<li>retdec-param-return：识别call指令参数的存放什么的</li>
<li><strong>retdec-simple-types</strong>：关键类型识别Pass，eqSet和equation</li>
<li>retdec-write-dsm：Generate the current disassembly？</li>
<li>retdec-remove-asm-instrs：Remove all special instructions used to map LLVM instructions to ASM instructions</li>
<li>retdec-class-hierarchy：好像是根据RTTI和vtable搞class的继承关系</li>
<li>retdec-select-fncs：如果config里面选择了部分函数，就把其他函数删了。</li>
<li>retdec-unreachable-funcs：删除不可达函数？</li>
<li>retdec-register-localization让所有寄存器变成局部变量</li>
<li>retdec-value-protect：Protect values from LLVM optimization passes</li>
<li><strong>retdec-stack-ptr-op-remove</strong>：重要的</li>
<li>retdec-remove-phi：</li>
<li>retdec-write-ll：</li>
<li>retdec-write-bc：</li>
<li>retdec-llvmir2hll：</li>
</ul>
<h3 id="retdec-栈恢复算法"><a class="header" href="#retdec-栈恢复算法">retdec 栈恢复算法</a></h3>
<p>源码在<code>retdec\src\bin2llvmir\optimizations\stack\stack.cpp</code>。总体思路非常简单，分析每个load和store用到的东西，提取成一个表达式树（SymbolicTree类）。首先判断表达式树里面有没有栈指针，没有就不处理。然后尝试把整个表达式树化简，把栈指针看作0，化简成一个常量，然后把这个常量当作栈偏移，创建一个alloca去替换它。</p>
<p>这个方法还是有很大问题，有许多处理不了的情况。从这个角度看，retdec确实是比ghidra差的。现在现有的开源反编译器里面也就ghidra最好了。比如如果存在memcpy这种函数的调用，由于直接传地址，所以不是load/store的形式，而是计算完地址直接传给函数了，导致没有将里面的值替换为新创建的alloca。</p>
<p><strong>代码解读</strong></p>
<ul>
<li>abi.cpp 主要负责提供两个函数，isStackPointer和（我们自己新增的）isMemory，判断一个值是否是栈指针。</li>
<li>reaching-definition.cpp 计算load和store之间的到达定值关系？</li>
<li>symbolic-tree.cpp 符号树。
<ul>
<li>expand操作，当初次构建符号树的时候，会从感兴趣的值开始反向遍历Use关系，生成符号树。
<ul>
<li>我们适配wasm时，让栈指针的子节点为常量0。方便后续化简栈指针偏移的访问为常量（之后的化简操作会将栈指针视为常量0）。（retdec在分析非wasm程序时，会为寄存器创建对应的全局变量，初始值为0，但是我们wasm的栈指针初始值不为0，所以需要修改。）</li>
</ul>
</li>
<li>simplifyNode操作，尝试将符号树化简。比如如果有算数操作，且两边都是常量，则会化简为运算后的结果。</li>
</ul>
</li>
<li>stack.cpp 栈分析的主体代码。遍历处理load/store指令。有三种情况：1 处理Load指令的指针，2 处理Store指令打算存进内存的值，3 处理store指令的指针
<ul>
<li>对要分析的Value构建SymbolicTree（expand操作）。</li>
<li>使用val2val这个map进行缓存，缓存已经化简过的结果，从被分析的value映射到化简后的ConstantInt。如果不在缓存里，继续后面的分析。</li>
<li>首先判断当前的SymbolicTree里面有没有栈指针，如果没有就直接返回，放弃处理。</li>
<li>化简当前的SymbolicTree，如果化简为ConstantInt常量，则继续处理，否则直接返回放弃处理。</li>
<li>（我们新增）使用off2alloca这个map从偏移映射到alloca指令，防止重复创建栈变量。</li>
<li>把化简后的常量当作栈偏移，为每个不同的栈偏移创建变量。变量类型从load/store中找的好像。</li>
<li>把当前被分析的Value替换为对应的Alloca指令。</li>
</ul>
</li>
<li>stack-pointer-op-remove.cpp 独立的pass，移除栈变量识别后无用的代码。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="retypd"><a class="header" href="#retypd">retypd</a></h1>
<p><a href="https://github.com/GrammaTech/retypd">retypd</a> 是一个高级的反编译算法，有一篇<a href="https://github.com/GrammaTech/retypd/blob/master/reference/paper.pdf">论文</a></p>
<p>资源：</p>
<ul>
<li>优先看<a href="https://github.com/GrammaTech/retypd/blob/master/reference/type-recovery.rst">这个介绍</a>。</li>
<li>这个<a href="https://github.com/GrammaTech/retypd/blob/master/reference/presentation_slides.pdf">PPT</a>比论文容易懂很多</li>
</ul>
<h4 id="monoid"><a class="header" href="#monoid">monoid</a></h4>
<p>读《Haskell趣学指南》的Monoids一节，理解一下。</p>
<h3 id="unification-based-type-inference-algorithms"><a class="header" href="#unification-based-type-inference-algorithms">unification-based type inference algorithms</a></h3>
<p>https://www.cs.cornell.edu/courses/cs3110/2011sp/Lectures/lec26-type-inference/type-inference.htm</p>
<h4 id="retypdghidra-配置"><a class="header" href="#retypdghidra-配置">retypd+ghidra 配置</a></h4>
<p>参考<a href="https://github.com/GrammaTech/retypd-ghidra-plugin">GrammaTech/retypd-ghidra-plugin: Retypd plugin for Ghidra reverse engineering framework from NSA (github.com)</a></p>
<ol>
<li>安装retypd </li>
</ol>
<pre><code class="language-Python">git clone https://github.com/GrammaTech/retypd
cd retypd
pip install .
</code></pre>
<ol start="2">
<li>编译<code>GhidraRetypd</code>  安装ghidra_retypd_provider</li>
</ol>
<pre><code class="language-Python">git clone https://github.com/GrammaTech/retypd-ghidra-plugin
cd retypd-ghidra-plugin
make
pip install .
</code></pre>
<ol start="3">
<li>修改 GhidraRetypd.zip中的extension.properties，添加</li>
</ol>
<pre><code class="language-Python">version=10.2.3
</code></pre>
<ol start="4">
<li>
<p>安装插件</p>
<ol>
<li>打开 Ghidra 软件，点击 &quot;File&quot; 菜单，选择 &quot;Install Extensions&quot; 选项。</li>
<li>在弹出的 &quot;Install Extensions&quot; 窗口中，点击 &quot;Browse&quot; 按钮选择你要安装的扩展程序。</li>
<li>选中你要安装的扩展程序文件（通常是一个 zip 压缩文件），然后点击 &quot;Open&quot; 按钮。</li>
<li>点击 &quot;OK&quot; 按钮开始安装扩展程序。在安装过程中，Ghidra 软件会自动解压缩扩展程序文件，并将它们安装到正确的目录中。</li>
<li>安装完成后，重启 Ghidra 软件。</li>
</ol>
</li>
</ol>
<p>为Ghidra 10.2.3 版本成功编译的retypd<a href="GhidraRetypd.zip">下载</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="现有论文"><a class="header" href="#现有论文">现有论文</a></h1>
<h3 id="重要资源"><a class="header" href="#重要资源">重要资源</a></h3>
<p><a href="https://ieeexplore.ieee.org/xpl/conhome/1000635/all-proceedings"><strong>Working Conference on Reverse Engineering (WCRE)：</strong></a></p>
<p><a href="https://dl.acm.org/conference/pprew"><strong>PPREW-5: Proceedings of the 5th Program Protection and Reverse Engineering Workshop</strong></a> 这个期刊好啊。</p>
<p><a href="https://dl.acm.org/conference/ssprew"><strong>SSPREW: Software Security, Protection, and Reverse Engineering Workshop</strong></a></p>
<p>其他：</p>
<ul>
<li><a href="https://github.com/avast/retdec/blob/05c9b11351d3e82012d823fa3709f940033768cf/publications/README.md">RetDec的publication</a></li>
<li><a href="https://www.backerstreet.com/decompiler/type_analysis.php">Decompiler Design - Type Analysis</a> 居然有介绍反编译器架构的网站。</li>
</ul>
<p>Github的两个list：</p>
<ul>
<li><a href="https://github.com/yasong/Awesome-Info-Inferring-Binary">Awesome-Info-Inferring-Binary</a></li>
<li><a href="https://github.com/SystemSecurityStorm/Awesome-Binary-Rewriting">Awesome-Binary-Rewriting</a></li>
</ul>
<h2 id="读论文"><a class="header" href="#读论文">读论文</a></h2>
<p>一篇很好的综述：<a href="https://yurichev.com/mirrors/vanEmmerik_ssa.pdf">Static Single Assignment for Decompilation (Boomerang)</a> 感觉可以抓住优化方面的脉络。</p>
<p>摸着引用看论文确实有点用</p>
<h3 id="控制流结构恢复-structural-analysis"><a class="header" href="#控制流结构恢复-structural-analysis">控制流结构恢复-structural analysis</a></h3>
<p>很多都是借用现有的type recovery，重点去讲structure recovery。</p>
<ul>
<li>
<p>【Phoenix】Native x86 Decompilation Using Semantics-Preserving Structural Analysis and Iterative Control-Flow Structuring <a href="https://kapravelos.com/teaching/csc591-s20/readings/decompilation.pdf">paper link</a></p>
<p><a href="https://users.ece.cmu.edu/~ejschwar/papers/arthesis14.pdf">Edward Schwartz's PhD thesis</a> 里面进一步介绍了Phoenix反编译器</p>
<p>这篇论文关注控制结构的恢复。控制结构的恢复最早是基于interval analysis的（？这是什么得学一学）。后面才被细化为structural analysis</p>
</li>
<li>
<p><a href="https://www.ndss-symposium.org/wp-content/uploads/2017/09/11_4_2.pdf">【Dream】No More Gotos: Decompilation Using Pattern-Independent Control-Flow Structuring and Semantics-Preserving Transformations</a> <a href="https://www.ndss-symposium.org/wp-content/uploads/2017/09/11NoMoreGotos.slide_.pdf">slides</a> <a href="https://github.com/USECAP/dream">code</a></p>
</li>
</ul>
<h3 id="类型恢复---type-recovery"><a class="header" href="#类型恢复---type-recovery">类型恢复 - Type Recovery</a></h3>
<ul>
<li>
<p><a href="http://users.ece.cmu.edu/~aavgerin/papers/tie-ndss-2011.pdf">【TIE】Principled Reverse Engineering of Types in Binary Programs.</a> 这篇基于VSA搞了自己的DVSA，主要区别是StridedInterval里可以放除esp外的变量符号？。重点主要在后面的约束求解部分。后面的类型系统和求解部分也非常复杂TODO。</p>
</li>
<li>
<p>【DIVINE】: DIscovering Variables IN Executables 这篇还是VSA系列的那些人写的。讲先用最简单的semi naive方法鉴别变量，跑VSA，然后拿VSA结果去生成约束跑ASI。迭代几次得到最好的结果。
里面说如果变量是8字节大小，那VSA直接无法处理，值总是Top（32位程序）。那就不能直接把内存最大切分粒度搞成4字节？？</p>
</li>
<li>
<p><a href="https://www.cs.purdue.edu/homes/xyzhang/Comp/ndss10.pdf">【REWARDS】Automatic Reverse Engineering of Data Structures from Binary Execution</a> TODO</p>
</li>
<li>
<p><a href="https://arxiv.org/pdf/1603.05495.pdf">【retypd】</a> 需要进一步学习类型系统的高级知识，比如subtyping。它不仅开源，而且不需要VSA的指针信息。可以与之前需要VSA的结合？<del>但是似乎没有说怎么从一整块栈内存中识别出变量。</del></p>
</li>
<li>
<p><a href="https://user.eng.umd.edu/~barua/elwazeer-PLDI-2013.pdf">【SecondWrite】</a></p>
</li>
</ul>
<h3 id="变量恢复"><a class="header" href="#变量恢复">变量恢复</a></h3>
<p>变量恢复和类型恢复关联较大。如果把函数开头分配的栈空间看作一个巨大的结构体，变量恢复就转换成了类型恢复。</p>
<p><a href="https://www.cs.virginia.edu/~yk2bb/data/osprey_sp21.pdf">OSPREY: Recovery of Variable and Data Structure
via Probabilistic Analysis for Stripped Binary</a> <a href="https://www.cs.purdue.edu/homes/zhan3299/res/SP21a_slides.pdf">slides</a> 把变量的访问看作变量存在的暗示，同时存在很多这样的暗示，使用概率性的推导。好像是基于后面那篇BDA的工作。</p>
<h3 id="c-反编译"><a class="header" href="#c-反编译">C++ 反编译</a></h3>
<p>C++的类给反编译带来了额外的困难，涉及到（复杂的）约束求解等。</p>
<ul>
<li>
<p><a href="https://edmcman.github.io/papers/ccs18.pdf">Using Logic Programming to Recover C++ Classes</a> C++反编译 
and Methods from Compiled Executables </p>
</li>
<li>
<p>SmartDec: Approaching C++ Decompilation.</p>
</li>
<li>
<p>Reconstruction of Class Hierarchies for Decompilation of C++ Programs.</p>
</li>
</ul>
<h3 id="vsa相关"><a class="header" href="#vsa相关">VSA相关</a></h3>
<ul>
<li>
<p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.76.637&amp;rep=rep1&amp;type=pdf">WYSINWYX: WHAT YOU SEE IS NOT WHAT YOU EXECUTE</a> 第三章讲了VSA的事情。它也讲了很多二进制分析的事情。</p>
<p>■ 文中提到的一些其他的没有用到VSA的方法：</p>
<p>[33] C. Cifuentes and A. Fraboulet. Interprocedural data flow recovery of high-level language code from assembly. Technical Report 421, Univ. Queensland, 1997.</p>
<p>[34] C. Cifuentes and A. Fraboulet. Intraprocedural static slicing of binary executables. In Proc. Int. Conf. on Software Maintenance (ICSM), pages 188–195, 1997.</p>
<p>[35] C. Cifuentes, D. Simon, and A. Fraboulet. Assembly to high-level language translation. In Proc. Int. Conf. on Software Maintenance (ICSM), pages 228–237, 1998.</p>
<p>[45] S.K. Debray, R. Muth, and M. Weippert. Alias analysis of executable code. In Proc. Principles of Programming Languages (POPL), pages 12–24, January 1998.</p>
</li>
<li>
<p><a href="https://research.cs.wisc.edu/wpis/papers/cc04.pdf">基础的VSA</a> Analyzing Memory Accesses in x86 Executables</p>
</li>
<li>
<p><a href="http://research.cs.wisc.edu/wpis/papers/etaps08.invited.pdf">Improved Memory-Access Analysis for x86 Executables</a>  GMOD-Based Merge Function</p>
<p>这篇论文开头有很多引用：Research carried out during the last decade by our research group [64, 65, 6, 56, 55, 7, 8, 36, 4, 49, 9] as well as by others [48, 22, 33, 14, 2, 31, 13, 44, 32, 3, 54, 37, 21, 46, 28, 19, 16, 34, 66] has developed the foundations for performing static analysis at the machine-code level.  能找到非常多的其他paper了？</p>
<p>没想到相比于源码级的分析，二进制级的分析还有好处。有很多源码层没有指明的实现细节（比如C++的表达式求值顺序），源码级分析想要sound需要考虑所有可能的实现，而二进制级的分析只需要考虑编译器选择的实现。</p>
</li>
<li>
<p>《DIVINE: DIscovering Variables IN Executables》 （VSA with ASI(Automated Struct Identification)）（栈变量恢复）VSA可以用于一定程度的变量恢复。</p>
</li>
<li>
<p><a href="https://www.zybuluo.com/SmashStack/note/847219">这人</a>想要实现Value Set Analysis到RadecoIL上。</p>
</li>
<li>
<p><a href="https://github.com/radareorg/radeco/tree/master/radeco-lib/src/analysis/valueset">这里</a> 也有人实现，还有WYSINWYNX那个论文相关的东西？</p>
</li>
<li>
<p><a href="http://www-verimag.imag.fr/~mounier/Enseignement/Software_Security/slides_lecture_7.pdf">这个课件</a>讲到了一点点。这门课是和安全相关的。TODO，不太看得懂。</p>
</li>
<li>
<p><a href="https://www.ndss-symposium.org/wp-content/uploads/bar2021_23002_paper.pdf">研究VSA对人工分析的帮助</a>。（对学习VSA没啥用）</p>
</li>
</ul>
<h3 id="其他-2"><a class="header" href="#其他-2">其他</a></h3>
<ul>
<li>
<p><a href="https://dl.acm.org/doi/abs/10.1145/3395363.3397370">【DecFuzzer】How far we have come: testing decompilation correctness of C decompilers</a> <a href="https://github.com/monkbai/DecFuzzer">代码</a></p>
<p>functionality-preserving disassembling and C style control structure recovery [17, 31, 47, 64, 65, 67]</p>
<p>变量恢复static analysis and inference techniques [10, 12, 13, 30, 54]. </p>
<p>fool-proof techniques for binary disassembling and decompilation [17, 31, 64-67].</p>
<p>EMI编译器测试看了下是插入了不影响语义的代码之后去开编译优化，发现优化器做出的错误决定而导致的crash。比如把一个不该执行的循环内操作提到外面。错误判断一些分支恒为真或假。是设置Csmith的输出使得只生成一个函数？？</p>
<p>本来Csmith生成的代码很多全局变量的使用。如果全局变量改变了，很难手动找到是哪个函数？它是生成了局部变量，然后把对全局变量的使用全替换成了局部变量，函数结束的时候把局部变量的值update到全局变量，这样如果全局变量变了，就肯定是在最后update的时候改变的。那手动看的时候不要继续找内部怎么使用？这样做有什么好处吗。。。可能是方便找到这个函数到底涉及到了哪些全局变量，然后方便只提取这些到反编译结果的全局变量？？</p>
</li>
<li>
<p><a href="http://web.archive.org/web/20180517094139/http://decompilation.info/sites/all/files/articles/C%20decompilation.pdf">C Decompilation : Is It Possible?</a> 2009的一篇</p>
<p>第二章相关工作里面有不少引用：</p>
<p>structural analysis：[4–6]，这个也用在了编译器：[8]。</p>
<p>unification-based algorithm for recovery of types：Mycroft [9]</p>
<p>现有反编译器：DCC decompiler [7]. Boomerang [11], REC [12] and Hex-Rays plug-in [13]</p>
</li>
<li>
<p><a href="https://www.rev.ng/downloads/iccst-18-paper.pdf">【rev.ng】rev.ng: A Multi-Architecture Framework for Reverse Engineering and Vulnerability Discovery.</a></p>
<p>这个反编译器开源了lifter：先转到Qemu IR然后转到LLVM IR。这个好像也不太和反编译相关，也只是搞插桩、fuzzing的。</p>
</li>
<li>
<p><a href="https://www.cs.unm.edu/~eschulte/data/bed.pdf">Evolving Exact Decompilation</a> 好像和主流的反编译技术不是特别相关。</p>
</li>
</ul>
<p><strong>最近的新论文</strong></p>
<ul>
<li>
<p><a href="https://www.usenix.org/system/files/sec19-guo.pdf">DEEPVSA</a>: Facilitating Value-set Analysis with Deep Learning for Postmortem Program Analysis 这篇参考意义不大，是ML结合的。</p>
</li>
<li>
<p>BDA: Practical Dependence Analysis for Binary Executables by Unbiased Whole-Program Path Sampling and Per-Path Abstract Interpretation</p>
</li>
<li>
<p>BinPointer: Towards Precise, Sound, and Scalable Binary-Level Pointer Analysis</p>
<p>里面提到了 <a href="https://www.cse.psu.edu/~gxt29/papers/cfgByDatalog_NDSS21.pdf">BPA: Refining Indirect Call Targets at the Binary Level</a>这篇也值得读。用了块内存的抽象解释。</p>
</li>
</ul>
<h3 id="其他零散资料"><a class="header" href="#其他零散资料">其他零散资料：</a></h3>
<ul>
<li>
<p>https://github.com/cmu-sei/pharos 涉及到很多反编译技术</p>
</li>
<li>
<p>https://news.ycombinator.com/item?id=11218138 两个人的讨论。里面推荐对两篇文章的逆向引用搜索：https://scholar.google.com/scholar?as_ylo=2018&amp;hl=en&amp;as_sdt=2005&amp;sciodt=0,5&amp;cites=1148004013363547510&amp;scipsc=   https://scholar.google.com/scholar?cites=7322807636381891759&amp;as_sdt=2005&amp;sciodt=0,5&amp;hl=en </p>
</li>
<li>
<p>https://github.com/toor-de-force/Ghidra-to-LLVM https://uwspace.uwaterloo.ca/bitstream/handle/10012/17976/Toor_Tejvinder.pdf?sequence=3&amp;isAllowed=y Ghidra Pcode编译到IR。代码太简单了。。栈内存好像是alloca出来的，可能还是想保持语义想运行。</p>
</li>
<li>
<p>https://github.com/decomp/decomp 这人也想基于LLVM IR然后去优化。https://github.com/decomp/doc 相关文档 </p>
</li>
<li>
<p><a href="http://www.program-transformation.org/Transform/DeCompilation">The Decompilation Wiki.</a></p>
</li>
<li>
<p><a href="https://github.com/repzret/dagger">github.com/repzret/dagger</a> 反编译到LLVM IR。aarch64还在开发过程中。<a href="https://llvm.org/devmtg/2013-04/bougacha-slides.pdf">介绍的slides</a></p>
<p>dagger主要讲的是反编译到IR上，找到语义等价的LLVM IR的指令的过程。感觉有点像编译器后端的Instruction Selection，可能能用上利用DAG（有向无环图）选择指令的技术。它是作为llvm的fork编写的，2017后就没有维护了。和llvm耦合好严重啊，都不知道哪里是它的代码。好像好复杂。</p>
</li>
<li>
<p>https://github.com/JuliaComputingOSS/llvm-cbe 曾经IR到C有一个backend，2016年被移除了。现在有人接手</p>
</li>
<li>
<p>https://corescholar.libraries.wright.edu/cgi/viewcontent.cgi?article=3277&amp;context=etd_all LLVM IR based decompilation。</p>
</li>
<li>
<p>https://github.com/lifting-bits/sleigh sleigh作为Ghidra的反编译器，是用C++写的，而且汇编到pcode的lift部分也是它负责的。所以用Ghidra可能也只要用这个就可以了。</p>
</li>
<li>
<p><a href="https://blog.grimm-co.com/2020/11/automated-struct-identification-with.html">Ghidra上的ASI https://blog.grimm-co.com/2020/11/automated-struct-identification-with.html</a> </p>
</li>
</ul>
<h3 id="领域的大佬"><a class="header" href="#领域的大佬">领域的大佬</a></h3>
<p>TODO</p>
<p><a href="https://www.cse.psu.edu/~gxt29/publications/">Gang Tan</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-notes"><a class="header" href="#other-notes">Other Notes</a></h1>
<p>这里包括一些其他笔记，如C++，CMake的使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-development"><a class="header" href="#c-development">C++ Development</a></h1>
<h3 id="stackoverflow"><a class="header" href="#stackoverflow">stackoverflow</a></h3>
<ol>
<li>代码规范遵守LLVM的，https://llvm.org/docs/CodingStandards.html#do-not-use-rtti-or-exceptions 注意不要使用异常处理，用abort替代。可以使用<a href="https://stackoverflow.com/questions/2849832/c-c-line-number">特殊的宏</a>辅助打印错误信息。
<pre><code class="language-cpp">if(this-&gt;globs.size() != 0) {
    std::cerr &lt;&lt; __FILE__ &lt;&lt; &quot;:&quot; &lt;&lt; __LINE__ &lt;&lt; &quot;: &quot; &lt;&lt; &quot;Error: Cannot add module when globals is not empty&quot; &lt;&lt; std::endl;
    std::abort();
}
</code></pre>
</li>
<li>最好不要在头文件里用using namespace。但是可以在函数体开头使用。 https://stackoverflow.com/questions/223021/whats-the-scope-of-the-using-declaration-in-c</li>
<li>返回值选择object还是pointer： https://stackoverflow.com/questions/13213912/returning-an-object-or-a-pointer-in-c</li>
<li>是否使用智能指针：https://stackoverflow.com/questions/106508/what-is-a-smart-pointer-and-when-should-i-use-one</li>
<li>用引用还是指针：https://stackoverflow.com/questions/7058339/when-to-use-references-vs-pointers</li>
<li>引用和指针的区别：https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable</li>
</ol>
<h3 id="注意事项"><a class="header" href="#注意事项">注意事项</a></h3>
<ol>
<li>注意相关STL函数使用要带上check。
<ol>
<li>vector使用back一定要检查是否是空！！！ <code>assert(stack.size() &gt; 0);</code></li>
</ol>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cmake-notes"><a class="header" href="#cmake-notes">CMake Notes</a></h1>
<h3 id="cmake-学习资料"><a class="header" href="#cmake-学习资料">CMake 学习资料</a></h3>
<ol>
<li>https://eliasdaler.github.io/using-cmake/</li>
<li>https://github.com/kigster/cmake-project-template 找一个模板项目作为参考</li>
</ol>
<h3 id="external-project"><a class="header" href="#external-project">External Project</a></h3>
<p>基本就是先添加ExternalProject_add，然后add_library指定IMPORTED，设置import路径。最后使用的时候额外增加一个add_dependencies关联到ExternalProject_add的target。</p>
<ol>
<li>https://cmake.org/cmake/help/latest/module/ExternalProject.html</li>
<li>https://stackoverflow.com/questions/51564251/correct-way-to-use-third-party-libraries-in-cmake-project/51567322#51567322</li>
<li>https://stackoverflow.com/questions/51661637/having-cmake-build-but-not-install-an-external-project</li>
<li>https://stackoverflow.com/questions/29533159/what-is-install-dir-useful-for-in-externalproject-add-command</li>
<li>ninja报错找不到import的库的构建方法： https://stackoverflow.com/questions/50400592/using-an-externalproject-download-step-with-ninja</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
